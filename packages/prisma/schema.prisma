generator kysely {
  provider = "prisma-kysely"
}

generator client {
  provider = "prisma-client-js"
}

generator json {
  provider = "prisma-json-types-generator"
}

generator zod {
  provider             = "zod-prisma-types"
  createInputTypes     = false
  writeBarrelFiles     = false
  useMultipleFiles     = true
  useDefaultValidators = false
}

datasource db {
  provider  = "postgresql"
  url       = env("NEXT_PRIVATE_DATABASE_URL")
  directUrl = env("NEXT_PRIVATE_DIRECT_DATABASE_URL")
}

// Todo: (RR7) Remove after RR7 migration.
enum IdentityProvider {
  DOCUMENSO
  GOOGLE
  OIDC
}

enum Role {
  ADMIN
  USER
}

model User {
  id               Int              @id @default(autoincrement())
  name             String?
  email            String           @unique
  emailVerified    DateTime?
  password         String? // Todo: (RR7) Remove after RR7 migration.
  source           String?
  signature        String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @default(now()) @updatedAt
  lastSignedIn     DateTime         @default(now())
  roles            Role[]           @default([USER])
  identityProvider IdentityProvider @default(DOCUMENSO) // Todo: (RR7) Remove after RR7 migration.
  avatarImageId    String?
  disabled         Boolean          @default(false)
  boards           Board[]
  lists            List[]

  accounts            Account[]
  sessions            Session[]
  passwordResetTokens PasswordResetToken[]

  ownedOrganisations Organisation[]
  organisationMember OrganisationMember[]

  twoFactorSecret      String?
  twoFactorEnabled     Boolean @default(false)
  twoFactorBackupCodes String?

  folders   Folder[]
  documents Document[]
  templates Template[]

  releases                            Releases[]
  event                               Event[]
  ticketTemplates                     TicketTemplate[]
  contracts                           Contract[]
  tuStreams                           tuStreams[]
  tuStreamsArtists                    tuStreamsArtists[]
  files                               Files[]
  territories                         Territories[]
  releasesArtists                     releasesArtists[]
  artists                             Artist[]
  distributionStatementMusicPlatforms DistributionStatementMusicPlatforms[]
  distributionStatementTerritories    DistributionStatementTerritories[]
  isrcArtists                         IsrcArtists[]
  distributionStatement               DistributionStatement[]
  Chat                                Chat[]
  lpmProductDisplayArtists            lpmProductDisplayArtists[]
  ChatDocument                        ChatDocument[]
  lpm                                 lpm[]
  iscrSongs                           IsrcSongs[]
  Suggestion                          Suggestion[]
  musicPlatforms                      MusicPlatforms[]
  taskAssignees                       TaskAssignee[]
  taskComments                        TaskComment[]
  taskAttachments                     TaskAttachment[]
  taskSubtasks                        Task[]

  verificationTokens VerificationToken[]
  apiTokens          ApiToken[]
  securityAuditLogs  UserSecurityAuditLog[]
  webhooks           Webhook[]
  siteSettings       SiteSettings[]
  passkeys           Passkey[]
  avatarImage        AvatarImage?           @relation(fields: [avatarImageId], references: [id], onDelete: SetNull)

  @@index([email])
}

model TeamProfile {
  id      String  @id @default(cuid())
  enabled Boolean @default(false)
  teamId  Int     @unique
  bio     String?

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

enum UserSecurityAuditLogType {
  ACCOUNT_PROFILE_UPDATE
  ACCOUNT_SSO_LINK
  AUTH_2FA_DISABLE
  AUTH_2FA_ENABLE
  PASSKEY_CREATED
  PASSKEY_DELETED
  PASSKEY_UPDATED
  PASSWORD_RESET
  PASSWORD_UPDATE
  SESSION_REVOKED
  SIGN_OUT
  SIGN_IN
  SIGN_IN_FAIL
  SIGN_IN_2FA_FAIL
  SIGN_IN_PASSKEY_FAIL
}

model UserSecurityAuditLog {
  id        Int                      @id @default(autoincrement())
  userId    Int
  createdAt DateTime                 @default(now())
  type      UserSecurityAuditLogType
  userAgent String?
  ipAddress String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PasswordResetToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  createdAt DateTime @default(now())
  expiry    DateTime
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  buyerId   String
  buyer     Buyer    @relation(fields: [buyerId], references: [id], onDelete: Cascade)
}

model Passkey {
  id                   String    @id @default(cuid())
  userId               Int
  name                 String
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @default(now())
  lastUsedAt           DateTime?
  credentialId         Bytes
  credentialPublicKey  Bytes
  counter              BigInt
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String[]

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AnonymousVerificationToken {
  id        String   @id @unique @default(cuid())
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model VerificationToken {
  id          Int      @id @default(autoincrement())
  secondaryId String   @unique @default(cuid())
  identifier  String
  token       String   @unique
  completed   Boolean  @default(false)
  expires     DateTime
  createdAt   DateTime @default(now())
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  buyerId     String?
  buyer       Buyer?   @relation(fields: [buyerId], references: [id], onDelete: Cascade)
}

enum WebhookTriggerEvents {
  DOCUMENT_CREATED
  DOCUMENT_SENT
  DOCUMENT_OPENED
  DOCUMENT_SIGNED
  DOCUMENT_COMPLETED
  DOCUMENT_REJECTED
  DOCUMENT_CANCELLED
}

model Webhook {
  id            String                 @id @default(cuid())
  webhookUrl    String
  eventTriggers WebhookTriggerEvents[]
  secret        String?
  enabled       Boolean                @default(true)
  createdAt     DateTime               @default(now())
  updatedAt     DateTime               @default(now()) @updatedAt
  userId        Int
  user          User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId        Int
  team          Team                   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  webhookCalls  WebhookCall[]
}

enum WebhookCallStatus {
  SUCCESS
  FAILED
}

model WebhookCall {
  id              String               @id @default(cuid())
  status          WebhookCallStatus
  url             String
  event           WebhookTriggerEvents
  requestBody     Json
  responseCode    Int
  responseHeaders Json?
  responseBody    Json?
  createdAt       DateTime             @default(now())
  webhookId       String
  webhook         Webhook              @relation(fields: [webhookId], references: [id], onDelete: Cascade)
}

enum ApiTokenAlgorithm {
  SHA512
}

model ApiToken {
  id        Int               @id @default(autoincrement())
  name      String
  token     String            @unique
  algorithm ApiTokenAlgorithm @default(SHA512)
  expires   DateTime?
  createdAt DateTime          @default(now())
  userId    Int?
  user      User?             @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId    Int
  team      Team              @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  INACTIVE
}

model Subscription {
  id                Int                @id @default(autoincrement())
  status            SubscriptionStatus @default(INACTIVE)
  planId            String             @unique
  priceId           String
  periodEnd         DateTime?
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  cancelAtPeriodEnd Boolean            @default(false)

  customerId String

  organisationId String       @unique
  organisation   Organisation @relation(fields: [organisationId], references: [id], onDelete: Cascade)

  @@index([organisationId])
}

/// @zod.import(["import { ZClaimFlagsSchema } from '@documenso/lib/types/subscription';"])
model SubscriptionClaim {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name   String
  locked Boolean @default(false)

  teamCount   Int
  memberCount Int

  flags Json /// [ClaimFlags] @zod.custom.use(ZClaimFlagsSchema)
}

/// @zod.import(["import { ZClaimFlagsSchema } from '@documenso/lib/types/subscription';"])
model OrganisationClaim {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  originalSubscriptionClaimId String?
  organisation                Organisation?

  teamCount   Int
  memberCount Int

  flags Json /// [ClaimFlags] @zod.custom.use(ZClaimFlagsSchema)
}

model Account {
  id                String  @id @default(cuid())
  userId            Int
  buyerId           String?
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  // Some providers return created_at so we need to make it optional
  created_at        Int?
  // Stops next-auth from crashing when dealing with AzureAD
  ext_expires_in    Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  password          String?

  user  User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  buyer Buyer? @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String @id @default(cuid())
  sessionToken String @unique
  userId       Int

  ipAddress String?
  userAgent String?
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User? @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
  BLOCKED
}

model Board {
  id         String          @id @default(cuid())
  name       String
  color      EventColor?
  image      String?
  visibility BoardVisibility @default(EVERYONE)
  teamId     Int
  userId     Int
  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  team       Team            @relation(fields: [teamId], references: [id], onDelete: Cascade)
  lists      List[]
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt
}

model List {
  id        String      @id @default(cuid())
  name      String
  teamId    Int
  userId    Int
  boardId   String
  board     Board       @relation(fields: [boardId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  team      Team        @relation(fields: [teamId], references: [id], onDelete: Cascade)
  pinned    Boolean     @default(false)
  color     EventColor?
  position  Int         @default(0)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @default(now()) @updatedAt
  tasks     Task[]

  @@index([teamId])
  @@index([boardId, position])
}

model Task {
  id          Int            @id @default(autoincrement())
  externalId  String?
  userId      Int
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  title       String
  description String?
  status      TaskStatus     @default(PENDING)
  priority    TaskPriority   @default(MEDIUM)
  dueDate     DateTime?
  assignees   TaskAssignee[]
  comments    TaskComment[]
  coverImage  String?
  list        List           @relation(fields: [listId], references: [id], onDelete: Cascade)
  listId      String
  position    Int            @default(0)

  tags         String[]  @default([])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @default(now()) @updatedAt
  completedAt  DateTime?
  deletedAt    DateTime?
  teamId       Int
  projectId    Int?
  parentTaskId Int?

  team            Team             @relation(fields: [teamId], references: [id])
  parentTask      Task?            @relation("TaskHierarchy", fields: [parentTaskId], references: [id])
  subtasks        Task[]           @relation("TaskHierarchy")
  taskAttachments TaskAttachment[]

  auditLogs TaskAuditLog[]

  @@index([userId])
  @@index([status])
  @@index([priority])
  @@index([dueDate])
  @@index([teamId])
  @@index([listId, position])
}

model TaskAttachment {
  id        Int      @id @default(autoincrement())
  taskId    Int // Requerido
  userId    Int // Requerido
  name      String // Requerido
  createdAt DateTime @default(now()) // Autom√°tico
  user      User     @relation(fields: [userId], references: [id])
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
}

model TaskComment {
  id        Int      @id @default(autoincrement())
  taskId    Int
  userId    Int
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
}

model TaskAssignee {
  id         Int      @id @default(autoincrement())
  taskId     Int
  userId     Int
  assignedAt DateTime @default(now())
  assignedBy Int /// User who assigned the task

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id])
}

model TaskAuditLog {
  id        String   @id @default(cuid())
  taskId    Int
  createdAt DateTime @default(now())
  type      String
  data      Json

  name      String?
  email     String?
  userId    Int?
  userAgent String?
  ipAddress String?

  task Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
}

enum DocumentStatus {
  DRAFT
  PENDING
  COMPLETED
  REJECTED
  PROCESSING
  ERROR
}

enum DocumentSource {
  DOCUMENT
  TEMPLATE
  TEMPLATE_DIRECT_LINK
  CHAT
}

enum DocumentVisibility {
  EVERYONE
  MANAGER_AND_ABOVE
  ADMIN
}

enum BoardVisibility {
  EVERYONE
  MANAGER_AND_ABOVE
  ADMIN
  ONLY_ME
}

enum FolderType {
  DOCUMENT
  TEMPLATE
  CHAT
  CONTRACT
  FILE
}

model Folder {
  id         String             @id @default(cuid())
  name       String
  userId     Int
  user       User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId     Int
  team       Team               @relation(fields: [teamId], references: [id], onDelete: Cascade)
  pinned     Boolean            @default(false)
  parentId   String?
  parent     Folder?            @relation("FolderToFolder", fields: [parentId], references: [id], onDelete: Cascade)
  documents  Document[]
  templates  Template[]
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @default(now()) @updatedAt
  subfolders Folder[]           @relation("FolderToFolder")
  visibility DocumentVisibility @default(EVERYONE)
  type       FolderType

  contracts Contract[]
  useToChat Boolean    @default(false)
  files     Files[]

  @@index([userId])
  @@index([teamId])
  @@index([parentId])
  @@index([type])
}

/// @zod.import(["import { ZDocumentAuthOptionsSchema } from '@documenso/lib/types/document-auth';", "import { ZDocumentFormValuesSchema } from '@documenso/lib/types/document-form-values';"])
model Document {
  id         Int     @id @default(autoincrement())
  qrToken    String? /// @zod.string.describe("The token for viewing the document using the QR code on the certificate.")
  externalId String? /// @zod.string.describe("A custom external ID you can use to identify the document.")

  userId Int /// @zod.number.describe("The ID of the user that created this document.")
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  teamId Int
  team   Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  authOptions             Json? /// [DocumentAuthOptions] @zod.custom.use(ZDocumentAuthOptionsSchema)
  formValues              Json? /// [DocumentFormValues] @zod.custom.use(ZDocumentFormValuesSchema)
  visibility              DocumentVisibility     @default(EVERYONE)
  documentBodyExtracted   DocumentBodyExtracted?
  title                   String
  status                  DocumentStatus         @default(DRAFT)
  recipients              Recipient[]
  fields                  Field[]
  shareLinks              DocumentShareLink[]
  documentDataId          String
  documentMeta            DocumentMeta?
  createdAt               DateTime               @default(now())
  updatedAt               DateTime               @default(now()) @updatedAt
  completedAt             DateTime?
  deletedAt               DateTime?
  templateId              Int?
  source                  DocumentSource
  useToChat               Boolean                @default(false)
  useLegacyFieldInsertion Boolean                @default(false)

  documentData DocumentData @relation(fields: [documentDataId], references: [id], onDelete: Cascade)
  template     Template?    @relation(fields: [templateId], references: [id], onDelete: SetNull)

  auditLogs DocumentAuditLog[]
  folder    Folder?            @relation(fields: [folderId], references: [id], onDelete: SetNull)
  folderId  String?
  Chat      Chat[]

  @@unique([documentDataId])
  @@index([userId])
  @@index([status])
  @@index([folderId])
}

model DocumentImages {
  id          String    @id @default(cuid())
  recipientId Int
  data        String
  createdAt   DateTime  @default(now())
  recipient   Recipient @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([recipientId])
}

model DocumentAuditLog {
  id         String   @id @default(cuid())
  documentId Int
  createdAt  DateTime @default(now())
  type       String
  data       Json

  // Details of the person who performed the action which caused the audit log.
  name      String?
  email     String?
  userId    Int?
  userAgent String?
  ipAddress String?

  Document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
}

enum DocumentDataType {
  S3_PATH
  BYTES
  BYTES_64
}

enum DocumentSigningOrder {
  PARALLEL
  SEQUENTIAL
}

model DocumentData {
  id          String           @id @default(cuid())
  type        DocumentDataType
  data        String
  initialData String
  document    Document?
  template    Template?
  Files       Files?
}

enum DocumentDistributionMethod {
  EMAIL
  NONE
}

/// @zod.import(["import { ZDocumentEmailSettingsSchema } from '@documenso/lib/types/document-email';"])
model DocumentMeta {
  id                     String               @id @default(cuid())
  subject                String?
  message                String?
  timezone               String?              @default("Etc/UTC") @db.Text
  password               String?
  dateFormat             String?              @default("yyyy-MM-dd hh:mm a") @db.Text
  documentId             Int                  @unique
  document               Document             @relation(fields: [documentId], references: [id], onDelete: Cascade)
  redirectUrl            String?
  signingOrder           DocumentSigningOrder @default(PARALLEL)
  allowDictateNextSigner Boolean              @default(false)

  typedSignatureEnabled  Boolean @default(true)
  uploadSignatureEnabled Boolean @default(true)
  drawSignatureEnabled   Boolean @default(true)

  language           String                     @default("en")
  distributionMethod DocumentDistributionMethod @default(EMAIL)

  emailSettings Json? /// [DocumentEmailSettings] @zod.custom.use(ZDocumentEmailSettingsSchema)
  emailReplyTo  String?
  emailId       String?
}

enum ReadStatus {
  NOT_OPENED
  OPENED
}

enum SendStatus {
  NOT_SENT
  SENT
}

enum SigningStatus {
  NOT_SIGNED
  SIGNED
  REJECTED
}

enum RecipientRole {
  CC
  SIGNER
  VIEWER
  APPROVER
  ASSISTANT
}

/// @zod.import(["import { ZRecipientAuthOptionsSchema } from '@documenso/lib/types/document-auth';"])
model Recipient {
  id                Int              @id @default(autoincrement())
  documentId        Int?
  templateId        Int?
  email             String           @db.VarChar(255)
  name              String           @default("") @db.VarChar(255)
  token             String
  documentDeletedAt DateTime?
  expired           DateTime?
  signedAt          DateTime?
  authOptions       Json? /// [RecipientAuthOptions] @zod.custom.use(ZRecipientAuthOptionsSchema)
  signingOrder      Int? /// @zod.number.describe("The order in which the recipient should sign the document. Only works if the document is set to sequential signing.")
  rejectionReason   String?
  role              RecipientRole    @default(SIGNER)
  readStatus        ReadStatus       @default(NOT_OPENED)
  signingStatus     SigningStatus    @default(NOT_SIGNED)
  sendStatus        SendStatus       @default(NOT_SENT)
  document          Document?        @relation(fields: [documentId], references: [id], onDelete: Cascade)
  template          Template?        @relation(fields: [templateId], references: [id], onDelete: Cascade)
  fields            Field[]
  signatures        Signature[]
  images            DocumentImages[]

  @@unique([documentId, email])
  @@unique([templateId, email])
  @@index([documentId])
  @@index([templateId])
  @@index([token])
}

enum FieldType {
  SIGNATURE
  FREE_SIGNATURE
  INITIALS
  NAME
  EMAIL
  DATE
  TEXT
  NUMBER
  RADIO
  CHECKBOX
  DROPDOWN
}

/// @zod.import(["import { ZFieldMetaNotOptionalSchema } from '@documenso/lib/types/field-meta';"])
model Field {
  id          Int        @id @default(autoincrement())
  secondaryId String     @unique @default(cuid())
  documentId  Int?
  templateId  Int?
  recipientId Int
  type        FieldType
  page        Int /// @zod.number.describe("The page number of the field on the document. Starts from 1.")
  positionX   Decimal    @default(0)
  positionY   Decimal    @default(0)
  width       Decimal    @default(-1)
  height      Decimal    @default(-1)
  customText  String
  inserted    Boolean
  document    Document?  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  template    Template?  @relation(fields: [templateId], references: [id], onDelete: Cascade)
  recipient   Recipient  @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  signature   Signature?
  fieldMeta   Json? /// [FieldMeta] @zod.custom.use(ZFieldMetaNotOptionalSchema)

  @@index([documentId])
  @@index([templateId])
  @@index([recipientId])
}

model Signature {
  id                     Int      @id @default(autoincrement())
  created                DateTime @default(now())
  recipientId            Int
  fieldId                Int      @unique
  signatureImageAsBase64 String?
  typedSignature         String?

  recipient Recipient @relation(fields: [recipientId], references: [id], onDelete: Cascade)
  field     Field     @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@index([recipientId])
}

model DocumentShareLink {
  id         Int      @id @default(autoincrement())
  email      String
  slug       String   @unique
  documentId Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, email])
}

enum OrganisationType {
  PERSONAL
  ORGANISATION
}

model Organisation {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  type          OrganisationType
  name          String
  url           String           @unique
  avatarImageId String?

  customerId   String?       @unique
  subscription Subscription?

  organisationClaimId String            @unique
  organisationClaim   OrganisationClaim @relation(fields: [organisationClaimId], references: [id])

  members OrganisationMember[]
  invites OrganisationMemberInvite[]
  groups  OrganisationGroup[]

  teams Team[]

  emailDomains       EmailDomain[]
  organisationEmails OrganisationEmail[]

  avatarImage AvatarImage? @relation(fields: [avatarImageId], references: [id], onDelete: SetNull)

  ownerUserId Int
  owner       User @relation(fields: [ownerUserId], references: [id], onDelete: Cascade)

  organisationGlobalSettingsId String                     @unique
  organisationGlobalSettings   OrganisationGlobalSettings @relation(fields: [organisationGlobalSettingsId], references: [id])
}

model OrganisationMember {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  organisationId String
  organisation   Organisation @relation(fields: [organisationId], references: [id], onDelete: Cascade)

  organisationGroupMembers OrganisationGroupMember[]

  @@unique([userId, organisationId])
}

model OrganisationMemberInvite {
  id        String   @id
  createdAt DateTime @default(now())

  email String
  token String @unique

  status OrganisationMemberInviteStatus @default(PENDING)

  organisationId   String
  organisation     Organisation           @relation(fields: [organisationId], references: [id], onDelete: Cascade)
  organisationRole OrganisationMemberRole
}

model OrganisationGroup {
  id   String  @id
  name String?

  type             OrganisationGroupType
  organisationRole OrganisationMemberRole

  organisationId String
  organisation   Organisation @relation(fields: [organisationId], references: [id], onDelete: Cascade)

  organisationGroupMembers OrganisationGroupMember[]

  teamGroups TeamGroup[]
}

model OrganisationGroupMember {
  id String @id

  groupId String
  group   OrganisationGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)

  organisationMember   OrganisationMember @relation(fields: [organisationMemberId], references: [id], onDelete: Cascade)
  organisationMemberId String

  @@unique([organisationMemberId, groupId])
}

model TeamGroup {
  id String @id

  organisationGroupId String
  organisationGroup   OrganisationGroup @relation(fields: [organisationGroupId], references: [id], onDelete: Cascade)

  teamRole TeamMemberRole

  teamId Int
  team   Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([teamId, organisationGroupId])
}

enum OrganisationGroupType {
  INTERNAL_ORGANISATION
  INTERNAL_TEAM
  CUSTOM
}

enum OrganisationMemberRole {
  ADMIN
  MANAGER
  MEMBER
}

enum TeamMemberRole {
  ADMIN
  MANAGER
  MEMBER
}

enum OrganisationMemberInviteStatus {
  ACCEPTED
  PENDING
  DECLINED
}

/// @zod.import(["import { ZDocumentEmailSettingsSchema } from '@documenso/lib/types/document-email';"])
model OrganisationGlobalSettings {
  id           String        @id
  organisation Organisation?

  documentVisibility        DocumentVisibility @default(EVERYONE)
  documentLanguage          String             @default("en")
  includeSenderDetails      Boolean            @default(true)
  includeSigningCertificate Boolean            @default(true)
  includeAuditLog           Boolean            @default(false)
  documentTimezone          String? // Nullable to allow using local timezones if not set.
  documentDateFormat        String             @default("yyyy-MM-dd hh:mm a")

  typedSignatureEnabled  Boolean @default(true)
  uploadSignatureEnabled Boolean @default(true)
  drawSignatureEnabled   Boolean @default(true)

  emailId String?
  email   OrganisationEmail? @relation(fields: [emailId], references: [id])

  emailReplyTo          String?
  // emailReplyToName      String? // Placeholder for future feature.
  emailDocumentSettings Json /// [DocumentEmailSettings] @zod.custom.use(ZDocumentEmailSettingsSchema)

  brandingEnabled        Boolean @default(false)
  brandingLogo           String  @default("")
  brandingUrl            String  @default("")
  brandingCompanyDetails String  @default("")
}

enum DocumentBodyExtractedStatus {
  ERROR
  PENDING
  COMPLETED
  PROCESSING
}

model DocumentBodyExtracted {
  id         String   @id @default(cuid())
  body       String
  status     String
  documentId Int      @unique
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
}

/// @zod.import(["import { ZDocumentEmailSettingsSchema } from '@documenso/lib/types/document-email';"])
model TeamGlobalSettings {
  id   String @id
  team Team?

  documentVisibility DocumentVisibility?
  documentLanguage   String?
  documentTimezone   String?
  documentDateFormat String?

  includeSenderDetails      Boolean?
  includeSigningCertificate Boolean?
  includeAuditLog           Boolean?

  typedSignatureEnabled  Boolean?
  uploadSignatureEnabled Boolean?
  drawSignatureEnabled   Boolean?

  emailId String?
  email   OrganisationEmail? @relation(fields: [emailId], references: [id])

  emailReplyTo          String?
  // emailReplyToName      String? // Placeholder for future feature.
  emailDocumentSettings Json? /// [DocumentEmailSettingsNullable] @zod.custom.use(ZDocumentEmailSettingsSchema)

  brandingEnabled        Boolean?
  brandingLogo           String?
  brandingUrl            String?
  brandingCompanyDetails String?
}

model Team {
  id            Int      @id @default(autoincrement())
  name          String
  url           String   @unique
  createdAt     DateTime @default(now())
  avatarImageId String?

  teamEmail         TeamEmail?
  emailVerification TeamEmailVerification?
  avatarImage       AvatarImage?           @relation(fields: [avatarImageId], references: [id], onDelete: SetNull)

  profile    TeamProfile?
  boards     Board[]
  lists      List[]
  documents  Document[]
  templates  Template[]
  folders    Folder[]
  apiTokens  ApiToken[]
  webhooks   Webhook[]
  teamGroups TeamGroup[]

  organisationId String
  organisation   Organisation @relation(fields: [organisationId], references: [id], onDelete: Cascade)

  teamGlobalSettingsId                String                                @unique
  teamGlobalSettings                  TeamGlobalSettings                    @relation(fields: [teamGlobalSettingsId], references: [id], onDelete: Cascade)
  Event                               Event[]
  distributionStatementMusicPlatforms DistributionStatementMusicPlatforms[]
  distributionStatementTerritories    DistributionStatementTerritories[]
  tuStreams                           tuStreams[]
  tuStreamsArtists                    tuStreamsArtists[]
  ticketTemplates                     TicketTemplate[]
  territories                         Territories[]
  isrcArtists                         IsrcArtists[]
  songs                               Songs[]
  musicPlatforms                      MusicPlatforms[]
  tasks                               Task[]
  isrcSongs                           IsrcSongs[]
  artists                             Artist[]
  distributionStatement               DistributionStatement[]
  releases                            Releases[]
  releasesArtists                     releasesArtists[]
  contract                            Contract[]
  Chat                                Chat[]
  contractTemplates                   ContractTemplate[]
  lpm                                 lpm[]
  lpmProductDisplayArtists            lpmProductDisplayArtists[]
  Files                               Files[]
}

model TeamEmail {
  teamId    Int      @id @unique
  createdAt DateTime @default(now())
  name      String
  email     String   @unique
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model TeamEmailVerification {
  teamId    Int      @id @unique
  name      String
  email     String
  token     String   @unique
  completed Boolean  @default(false)
  expiresAt DateTime
  createdAt DateTime @default(now())

  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

enum TemplateType {
  PUBLIC
  PRIVATE
}

/// @zod.import(["import { ZDocumentEmailSettingsSchema } from '@documenso/lib/types/document-email';"])
model TemplateMeta {
  id                     String                     @id @default(cuid())
  subject                String?
  message                String?
  timezone               String?                    @default("Etc/UTC") @db.Text
  password               String?
  dateFormat             String?                    @default("yyyy-MM-dd hh:mm a") @db.Text
  signingOrder           DocumentSigningOrder?      @default(PARALLEL)
  allowDictateNextSigner Boolean                    @default(false)
  distributionMethod     DocumentDistributionMethod @default(EMAIL)

  typedSignatureEnabled  Boolean @default(true)
  uploadSignatureEnabled Boolean @default(true)
  drawSignatureEnabled   Boolean @default(true)

  templateId  Int      @unique
  template    Template @relation(fields: [templateId], references: [id], onDelete: Cascade)
  redirectUrl String?
  language    String   @default("en")

  emailSettings Json? /// [DocumentEmailSettings] @zod.custom.use(ZDocumentEmailSettingsSchema)
  emailReplyTo  String?
  emailId       String?
}

/// @zod.import(["import { ZDocumentAuthOptionsSchema } from '@documenso/lib/types/document-auth';"])
model Template {
  id                     Int                @id @default(autoincrement())
  externalId             String?
  type                   TemplateType       @default(PRIVATE)
  title                  String
  visibility             DocumentVisibility @default(EVERYONE)
  authOptions            Json? /// [DocumentAuthOptions] @zod.custom.use(ZDocumentAuthOptionsSchema)
  templateMeta           TemplateMeta?
  templateDocumentDataId String
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @default(now()) @updatedAt
  publicTitle            String             @default("")
  publicDescription      String             @default("")

  useLegacyFieldInsertion Boolean @default(false)

  userId Int
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  teamId Int
  team   Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  templateDocumentData DocumentData @relation(fields: [templateDocumentDataId], references: [id], onDelete: Cascade)

  recipients Recipient[]
  fields     Field[]
  directLink TemplateDirectLink?
  documents  Document[]

  folder   Folder? @relation(fields: [folderId], references: [id], onDelete: SetNull)
  folderId String?

  @@unique([templateDocumentDataId])
  @@index([userId])
}

model TemplateDirectLink {
  id         String   @id @unique @default(cuid())
  templateId Int      @unique
  token      String   @unique
  createdAt  DateTime @default(now())
  enabled    Boolean

  directTemplateRecipientId Int

  template Template @relation(fields: [templateId], references: [id], onDelete: Cascade)
}

model SiteSettings {
  id                   String   @id
  enabled              Boolean  @default(false)
  data                 Json
  lastModifiedByUserId Int?
  lastModifiedAt       DateTime @default(now())
  lastModifiedByUser   User?    @relation(fields: [lastModifiedByUserId], references: [id], onDelete: SetNull)
}

enum BackgroundJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model BackgroundJob {
  id         String              @id @default(cuid())
  status     BackgroundJobStatus @default(PENDING)
  payload    Json?
  retried    Int                 @default(0)
  maxRetries Int                 @default(3)

  // Taken from the job definition
  jobId   String
  name    String
  version String

  submittedAt   DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  completedAt   DateTime?
  lastRetriedAt DateTime?

  tasks BackgroundJobTask[]
}

enum BackgroundJobTaskStatus {
  PENDING
  COMPLETED
  FAILED
}

model BackgroundJobTask {
  id     String                  @id
  name   String
  status BackgroundJobTaskStatus @default(PENDING)

  result     Json?
  retried    Int   @default(0)
  maxRetries Int   @default(3)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?

  jobId         String
  backgroundJob BackgroundJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
}

model AvatarImage {
  id    String @id @default(cuid())
  bytes String

  team         Team[]
  user         User[]
  organisation Organisation[]
}

enum EmailDomainStatus {
  PENDING
  ACTIVE
}

model EmailDomain {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  status EmailDomainStatus @default(PENDING)

  selector   String @unique
  domain     String @unique
  publicKey  String
  privateKey String

  organisationId String
  organisation   Organisation @relation(fields: [organisationId], references: [id], onDelete: Cascade)

  emails OrganisationEmail[]
}

model OrganisationEmail {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  email     String @unique
  emailName String
  // replyTo   String?

  emailDomainId String
  emailDomain   EmailDomain @relation(fields: [emailDomainId], references: [id], onDelete: Cascade)

  organisationId String
  organisation   Organisation @relation(fields: [organisationId], references: [id], onDelete: Cascade)

  organisationGlobalSettings OrganisationGlobalSettings[]
  teamGlobalSettings         TeamGlobalSettings[]
}

model ContractTemplate {
  id        Int       @id @default(autoincrement())
  name      String?   @db.VarChar(100)
  body      String?
  url       String?   @db.Text
  type      String?
  status    String?
  teamId    Int
  team      Team      @relation(fields: [teamId], references: [id])
  createdAt DateTime  @default(now())
  updatedAt DateTime  @default(now()) @updatedAt
  deletedAt DateTime?

  @@map("ContractTemplates")
}

model Chat {
  id               String              @id @default(cuid())
  createdAt        DateTime
  title            String              @db.Text
  userId           Int
  documentId       Int?
  teamId           Int
  visibility       String              @default("private") @db.VarChar(255)
  crmChatCreatedAt DateTime?
  user             User                @relation(fields: [userId], references: [id])
  document         Document?           @relation(fields: [documentId], references: [id])
  team             Team                @relation(fields: [teamId], references: [id])
  messagesV1       MessageDeprecated[]
  messagesV2       Message[]
  votesV1          VoteDeprecated[]
  votesV2          Vote[]

  @@map("Chat")
}

// DEPRECATED: Will be removed in the future
model MessageDeprecated {
  id        String   @id @default(cuid())
  chatId    String
  role      String   @db.VarChar(255)
  content   Json
  createdAt DateTime

  chat  Chat             @relation(fields: [chatId], references: [id])
  votes VoteDeprecated[]

  @@map("Message")
}

model Message {
  id          String   @id @default(cuid())
  chatId      String
  role        String   @db.VarChar(255)
  parts       Json
  attachments Json
  createdAt   DateTime

  chat  Chat   @relation(fields: [chatId], references: [id])
  votes Vote[]

  @@map("MessageV2")
}

// DEPRECATED: Will be removed in the future
model VoteDeprecated {
  chatId    String
  messageId String
  isUpvoted Boolean

  chat    Chat              @relation(fields: [chatId], references: [id])
  message MessageDeprecated @relation(fields: [messageId], references: [id])

  @@id([chatId, messageId])
  @@map("Vote")
}

model Vote {
  chatId    String
  messageId String
  isUpvoted Boolean

  chat    Chat    @relation(fields: [chatId], references: [id])
  message Message @relation(fields: [messageId], references: [id])

  @@id([chatId, messageId])
  @@map("Vote_v2")
}

model ChatDocument {
  id        String   @default(cuid())
  createdAt DateTime
  title     String   @db.Text
  content   String?  @db.Text
  kind      String   @default("text") @db.VarChar(255)
  userId    Int

  user        User         @relation(fields: [userId], references: [id])
  suggestions Suggestion[]

  @@id([id, createdAt])
  @@map("ChatDocument")
}

model Suggestion {
  id                String   @id @default(cuid())
  documentId        String
  documentCreatedAt DateTime
  originalText      String   @db.Text
  suggestedText     String   @db.Text
  description       String?  @db.Text
  isResolved        Boolean  @default(false)
  userId            Int
  createdAt         DateTime

  user     User         @relation(fields: [userId], references: [id])
  // Note: The foreign key relation is commented out in your Drizzle schema
  // You'll need to uncomment and fix this if needed
  document ChatDocument @relation(fields: [documentId, documentCreatedAt], references: [id, createdAt])

  @@map("Suggestion")
}

model Event {
  id           Int           @id @default(autoincrement())
  name         String        @db.VarChar(300)
  description  String?       @db.VarChar(200)
  image        String?       @db.Text
  teamId       Int
  userId       Int?
  published    Boolean       @default(false)
  venue        String?       @db.VarChar(300)
  artists      Artist[]
  beginning    DateTime      @default(now())
  end          DateTime      @default(now())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  deletedAt    DateTime?
  allDay       Boolean       @default(false)
  color        EventColor?
  queues       Queue[]
  team         Team          @relation(fields: [teamId], references: [id])
  user         User?         @relation(fields: [userId], references: [id])
  eventDates   EventDate[]
  ticketTypes  TicketType[]
  ticketBuyers TicketBuyer[]
}

enum EventColor {
  blue
  orange
  violet
  rose
  emerald
  sky

  @@map("event_colors")
}

model EventDate {
  id        String   @id @default(cuid())
  eventId   Int      @map("event_id")
  start     DateTime @map("start")
  end       DateTime @map("end")
  allDay    Boolean  @default(false) @map("all_day")
  createdAt DateTime @default(now()) @map("created_at")

  Event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
  @@map("rescheduled_event_dates")
}

enum BuyerRole {
  ADMIN
  USER
}

model Order {
  id           Int        @id @default(autoincrement())
  buyerId      String
  ticketTypeId Int
  quantity     Int        @default(1)
  status       String     @default("In process")
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  ticketType   TicketType @relation(fields: [ticketTypeId], references: [id])

  @@index([buyerId])
  @@index([ticketTypeId])
}

model SessionBuyers {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  buyerId      String
  expires      DateTime
  buyer        Buyer    @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  @@index([buyerId])
  @@map(name: "sessions")
}

// Buyers table
model Buyer {
  id            String    @id @default(cuid())
  password      String?
  razon         String?
  uid           String?   @unique
  name          String?
  rfc           String?
  email         String?   @unique
  emailVerified DateTime?
  phoneNumber   String?   @db.VarChar(20)
  image         String?
  createdAt     DateTime  @default(now()) @map(name: "created_at")
  updatedAt     DateTime  @default(now()) @map(name: "updated_at")
  role          BuyerRole @default(USER)

  accounts              Account[]
  sessionBuyers         SessionBuyers[]
  ticketBuyers          TicketBuyer[]
  verificationTokens    VerificationToken[]
  queues                Queue[]
  isTwoFactorEnabled    Boolean                @default(false)
  twoFactorConfirmation TwoFactorConfirmation?

  stripeCustomerId       String?              @unique @map(name: "stripe_customer_id")
  stripeSubscriptionId   String?              @unique @map(name: "stripe_subscription_id")
  stripePriceId          String?              @map(name: "stripe_price_id")
  stripeCurrentPeriodEnd DateTime?            @map(name: "stripe_current_period_end")
  PasswordResetToken     PasswordResetToken[]

  @@map(name: "buyers")
}

model TwoFactorConfirmation {
  id String @id @default(cuid())

  buyerId String
  buyer   Buyer  @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  @@unique([buyerId])
}

model Queue {
  id        String   @id @default(cuid())
  buyerId   String
  eventId   Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  status    String   @default("pending")
  buyer     Buyer    @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([buyerId])
  @@index([eventId])
}

model TicketTemplate {
  id                 Int       @id @default(autoincrement())
  name               String    @db.VarChar(100)
  price              Int? // Precio sugerido
  maxQuantityPerUser Int       @default(5)
  description        String?
  quantity           Int?
  imageUrl           String?   @db.Text
  isActive           Boolean   @default(true)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  deletedAt          DateTime?
  teamId             Int
  userId             Int?

  team Team  @relation(fields: [teamId], references: [id])
  user User? @relation(fields: [userId], references: [id])

  @@index([teamId])
  @@index([userId])
}

// Ticket types table
model TicketType {
  id                 Int       @id @default(autoincrement())
  name               String?   @db.VarChar(100)
  eventId            Int
  price              Int?
  uid                String?
  maxQuantityPerUser Int       @default(5)
  quantity           Int?
  available          Int?
  description        String?
  seatNumber         Int?
  stripeProductId    String?   @db.Text
  stripePriceId      String?   @db.Text
  imageUrl           String?   @db.Text
  status             String    @default("valid") @db.VarChar(20)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  deletedAt          DateTime?
  orders             Order[]
  event              Event     @relation(fields: [eventId], references: [id])
}

// Tickets buyers table
model TicketBuyer {
  id              Int       @id @default(autoincrement())
  name            String?   @db.VarChar(100)
  eventId         Int
  buyerId         String
  ticketId        Int?
  price           Int?
  quantity        Int?
  stripeProductId String?   @db.Text
  imageUrl        String?   @db.Text
  status          String    @default("valid") @db.VarChar(20)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?

  event Event @relation(fields: [eventId], references: [id])
  buyer Buyer @relation(fields: [buyerId], references: [id])
}

enum songRoles {
  WRITER
  COMPOSER
  ARRANGER
  PRODUCER
  MIXER
  MASTERING_ENGINEER
}

model Writers {
  id            Int         @id @default(autoincrement())
  name          String?
  createdAt     DateTime    @default(now())
  teamId        Int
  updatedAt     DateTime    @default(now()) @updatedAt
  songroles     songRoles[] @default([WRITER])
  avatarImageId String?
  disabled      Boolean?    @default(false)
  // event         Event[]
  // lpm           lpm[]
  url           String?     @unique

  // ArtistProfile ArtistProfile?
}

model lpmProductDisplayArtists {
  id        Int      @id @default(autoincrement())
  artistId  Int
  lpm       lpm[]
  createdAt DateTime @default(now())
  userId    Int?
  teamId    Int

  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id])
}

model releasesArtists {
  id        Int        @id @default(autoincrement())
  artistId  Int
  Releases  Releases[]
  createdAt DateTime   @default(now())
  userId    Int?
  teamId    Int

  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id])
}

model Artist {
  id                Int                        @id @default(autoincrement())
  name              String
  createdAt         DateTime                   @default(now())
  updatedAt         DateTime                   @default(now()) @updatedAt
  roles             Role[]                     @default([USER])
  avatarImageId     String?
  disabled          Boolean?                   @default(false)
  event             Event[]
  url               String?                    @unique
  ArtistProfile     ArtistProfile?
  isrcArtists       IsrcArtists[]
  releases          Releases[]
  releasesArtists   releasesArtists[]
  lpmProductArtists lpmProductDisplayArtists[]
  songs             Songs[]
  isrcSongs         IsrcSongs[] // Added for many-to-many relation with IsrcSongs
  lpm               lpm[]
  userId            Int?
  teamId            Int
  tuStreams         tuStreams[]
  tuStreamsArtists  tuStreamsArtists[]

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  team Team  @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model ArtistProfile {
  id       String  @id @default(cuid())
  enabled  Boolean @default(false)
  artistId Int     @unique
  bio      String?
  Artist   Artist? @relation(fields: [artistId], references: [id], onDelete: Cascade)
}

enum TypeSongAlbum {
  SONG
  ALBUM
}

enum StatusSongAlbum {
  DELETED
  RELEASED
  PENDING
  DRAFT
}

model Songs {
  id                Int               @id @default(autoincrement())
  name              String?
  author            String?
  teamId            Int
  publisherMexico   String?
  publisherUSA      String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @default(now()) @updatedAt
  disabled          Boolean           @default(false)
  artists           Artist[]
  url               String?           @unique
  type              TypeSongAlbum[]
  status            StatusSongAlbum[]
  uniqueIdentifier  String?           @unique @default(cuid())
  royaltyPercentage String?
  team              Team              @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

model lpm {
  id                                  Int                        @id @default(autoincrement())
  productId                           String?                    @map("productId")
  productType                         String?                    @map("Product Type")
  productTitle                        String?                    @map("Product Title")
  productVersion                      String?                    @map("Product Version")
  productDisplayArtist                String?                    @map("Product Display Artist")
  parentLabel                         String?                    @map("Parent Label")
  label                               String?                    @map("label")
  originalReleaseDate                 DateTime?                  @map("Original Release Date")
  releaseDate                         DateTime?                  @map("Release Date")
  upc                                 String?                    @map("UPC")
  catalog                             String?                    @map("Catalog ")
  productPriceTier                    String?                    @map("Product Price Tier")
  productGenre                        String?                    @map("Product Genre")
  submissionStatus                    String?                    @map("Submission Status")
  productCLine                        String?                    @map("Product C Line")
  productPLine                        String?                    @map("Product P Line")
  preOrderDate                        DateTime?                  @map("PreOrder Date")
  exclusives                          String?                    @map("Exclusives")
  explicitLyrics                      String?                    @map("ExplicitLyrics")
  productPlayLink                     String?                    @map("Product Play Link")
  linerNotes                          String?                    @map("Liner Notes")
  primaryMetadataLanguage             String?                    @map("Primary Metadata Language")
  compilation                         String?                    @map("Compilation")
  pdfBooklet                          String?                    @map("PDF Booklet")
  timedReleaseDate                    DateTime?                  @map("Timed Release Date")
  timedReleaseMusicServices           DateTime?                  @map("Timed Release Music Services")
  lastProcessDate                     DateTime?                  @map("Last Process Date")
  importDate                          DateTime?                  @map("Import Date")
  createdBy                           String?                    @map("Created By")
  lastModified                        DateTime?                  @map("Last Modified")
  submittedAt                         DateTime?                  @map("Submitted At")
  submittedBy                         String?                    @map("Submitted By")
  vevoChannel                         String?                    @map("Vevo Channel")
  trackType                           String?                    @map("TrackType")
  trackId                             String?                    @map("Track Id")
  trackVolume                         Boolean?                   @map("Track Volume")
  trackNumber                         String?                    @map("Track Number")
  trackName                           String?                    @map("Track Name")
  trackVersion                        String?                    @map("Track Version")
  trackDisplayArtist                  String?                    @map("Track Display Artist")
  isrc                                String?                    @map("Isrc")
  trackPriceTier                      String?                    @map("Track Price Tier")
  trackGenre                          String?                    @map("Track Genre")
  audioLanguage                       String?                    @map("Audio Language")
  trackCLine                          String?                    @map("Track C Line")
  trackPLine                          String?                    @map("Track P Line")
  writersComposers                    String?                    @map("WritersComposers")
  publishersCollectionSocieties       String?                    @map("PublishersCollection Societies")
  withholdMechanicals                 String?                    @map("Withhold Mechanicals")
  preOrderType                        String?                    @map("PreOrder Type")
  instantGratificationDate            DateTime?                  @map("Instant Gratification Date")
  duration                            String?                    @map("Duration")
  sampleStartTime                     String?                    @map("Sample Start Time")
  explicitLyricsTrack                 String?                    @map("Explicit Lyrics")
  albumOnly                           String?                    @map("Album Only")
  lyrics                              String?                    @map("Lyrics")
  additionalContributorsPerforming    String?                    @map("AdditionalContributorsPerforming")
  additionalContributorsNonPerforming String?                    @map("AdditionalContributorsNonPerforming")
  producers                           String?                    @map("Producers")
  continuousMix                       String?                    @map("Continuous Mix")
  continuouslyMixedIndividualSong     String?                    @map("Continuously Mixed Individual Song")
  trackPlayLink                       String?                    @map("Track Play Link")
  deletedAt                           DateTime?                  @map("Deleted At")
  // writerId   Int?
  userId                              Int?
  teamId                              Int
  artists                             Artist[]
  lpmArtists                          lpmProductDisplayArtists[]
  // writer     Writers?                   @relation(fields: [writerId], references: [id], onDelete: SetNull)
  user                                User?                      @relation(fields: [userId], references: [id], onDelete: SetNull)
  team                                Team                       @relation(fields: [teamId], references: [id], onDelete: Cascade)
}

enum ContractStatus {
  VIGENTE
  FINALIZADO
  NO_ESPECIFICADO
}

enum ExpansionPossibility {
  SI
  NO
  NO_ESPECIFICADO
}

enum RetentionAndCollectionPeriod {
  SI
  NO
  NO_ESPECIFICADO
}

enum ContractType {
  ARRENDAMIENTOS
  ALQUILERES
  VEHICULOS
  SERVICIOS
  ARTISTAS
}

model Contract {
  id       Int     @id @default(autoincrement())
  title    String  @db.Text
  fileName String? @db.Text

  artists                     String?                       @db.Text
  startDate                   DateTime?
  endDate                     DateTime?
  isPossibleToExpand          ExpansionPossibility          @default(NO_ESPECIFICADO)
  possibleExtensionTime       String?
  status                      ContractStatus?               @default(NO_ESPECIFICADO)
  collectionPeriod            RetentionAndCollectionPeriod?
  retentionPeriod             RetentionAndCollectionPeriod?
  retentionPeriodDescription  String?
  retentionPeriodDuration     String?
  collectionPeriodDescription String?
  collectionPeriodDuration    String?
  contractType                ContractType?
  documentId                  Int
  createdAt                   DateTime                      @default(now())
  updatedAt                   DateTime                      @updatedAt
  deletedAt                   DateTime?
  summary                     String?                       @db.Text
  userId                      Int?
  teamId                      Int
  folder                      Folder?                       @relation(fields: [folderId], references: [id], onDelete: Cascade)
  folderId                    String?
  user                        User?                         @relation(fields: [userId], references: [id], onDelete: SetNull)
  team                        Team                          @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([folderId])
  @@map("Contracts")
}

model Territories {
  id                               Int                                @id @default(autoincrement())
  name                             String?                            @unique
  createdAt                        DateTime                           @default(now())
  updatedAt                        DateTime                           @default(now()) @updatedAt
  avatarImageId                    String?
  disabled                         Boolean?                           @default(false)
  userId                           Int?
  teamId                           Int?
  distributionStatementTerritories DistributionStatementTerritories[]
  user                             User?                              @relation(fields: [userId], references: [id], onDelete: SetNull)
  team                             Team?                              @relation(fields: [teamId], references: [id], onDelete: SetNull)
}

model DistributionStatementTerritories {
  id                    Int                     @id @default(autoincrement())
  territoryId           Int
  name                  String
  createdAt             DateTime                @default(now())
  userId                Int?
  teamId                Int
  distributionStatement DistributionStatement[]

  user      User?       @relation(fields: [userId], references: [id], onDelete: SetNull)
  team      Team        @relation(fields: [teamId], references: [id], onDelete: Cascade)
  territory Territories @relation(fields: [territoryId], references: [id])
}

model DistributionStatementMusicPlatforms {
  id                    Int                     @id @default(autoincrement())
  platformId            Int
  name                  String
  createdAt             DateTime                @default(now())
  userId                Int?
  teamId                Int
  distributionStatement DistributionStatement[]

  user     User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  team     Team           @relation(fields: [teamId], references: [id], onDelete: Cascade)
  platform MusicPlatforms @relation(fields: [platformId], references: [id])
}

model MusicPlatforms {
  id                                  Int                                   @id @default(autoincrement())
  name                                String?                               @unique
  createdAt                           DateTime                              @default(now())
  updatedAt                           DateTime                              @default(now()) @updatedAt
  avatarImageId                       String?
  disabled                            Boolean?                              @default(false)
  url                                 String?                               @unique
  userId                              Int?
  teamId                              Int?
  distributionStatementMusicPlatforms DistributionStatementMusicPlatforms[]

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
  team Team? @relation(fields: [teamId], references: [id], onDelete: SetNull)
}

model DistributionStatement {
  id                                  Int                                   @id @default(autoincrement())
  marketingOwner                      String?                               @map("Marketing Owner")
  nombreDistribucion                  String?                               @map("Nombre Distribucion")
  proyecto                            String?                               @map("Projecto")
  numeroDeCatalogo                    String?                               @map("Numero de Catalogo")
  upc                                 String?                               @map("UPC")
  localProductNumber                  String?                               @map("Local Product Number")
  isrc                                String?                               @map("ISRC")
  tituloCatalogo                      String?                               @map("Titulo catalogo")
  mesReportado                        Int?                                  @map("Mes Reportado")
  territorio                          String?                               @map("Territorio")
  codigoDelTerritorio                 String?                               @map("Codigo del Territorio")
  nombreDelTerritorio                 String?                               @map("Nombre del Territorio")
  tipoDePrecio                        String?                               @map("Tipo de Precio")
  tipoDeIngreso                       String?                               @map("Tipo de Ingreso")
  venta                               Float?                                @map("Venta")
  rtl                                 Float?                                @map("RTL")
  ppd                                 Float?                                @map("PPD")
  rbp                                 Float?                                @map("RBP")
  tipoDeCambio                        Float?                                @map("Tipo de Cambio:")
  valorRecibido                       Float?                                @map("Valor Recibido")
  regaliasArtisticas                  Float?                                @map("Regalias Artisticas")
  costoDistribucion                   Float?                                @map("Costo Distribucion")
  copyright                           Float?                                @map("Copyright")
  cuotaAdministracion                 Float?                                @map("Cuota Administracion")
  costoCarga                          Float?                                @map("Costo Carga")
  otrosCostos                         Float?                                @map("Otros Costos")
  ingresosRecibidos                   Float?                                @map("Ingresos Recibidos")
  createdAt                           DateTime                              @default(now())
  updatedAt                           DateTime                              @default(now()) @updatedAt
  userId                              Int?
  teamId                              Int
  distributionStatementMusicPlatforms DistributionStatementMusicPlatforms[]
  distributionStatementTerritories    DistributionStatementTerritories[]
  deletedAt                           DateTime?
  user                                User?                                 @relation(fields: [userId], references: [id], onDelete: SetNull)
  team                                Team                                  @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([teamId])
}

enum Release {
  Soft
  Focus
}

enum TypeOfRelease {
  Sencillo
  Album
  EP
}

model Releases {
  id             Int            @id @default(autoincrement())
  date           DateTime?
  artist         String?
  lanzamiento    String?
  typeOfRelease  TypeOfRelease?
  release        Release?
  uploaded       String?
  streamingLink  String?
  assets         Boolean?
  canvas         Boolean?
  cover          Boolean?
  audioWAV       Boolean?
  video          Boolean?
  banners        Boolean?
  pitch          Boolean?
  EPKUpdates     Boolean?
  WebSiteUpdates Boolean?
  Biography      Boolean?
  userId         Int?
  teamId         Int
  artists        Artist[]

  releasesArtists releasesArtists[]
  user            User?             @relation(fields: [userId], references: [id], onDelete: SetNull)
  team            Team              @relation(fields: [teamId], references: [id], onDelete: Cascade)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @default(now())
  deletedAt       DateTime?
}

model IsrcArtists {
  id        Int         @id @default(autoincrement())
  artistId  Int
  isrcSongs IsrcSongs[]
  createdAt DateTime    @default(now())
  userId    Int?
  teamId    Int

  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id])
}

model IsrcSongs {
  id        Int       @id @default(autoincrement())
  date      DateTime?
  isrc      String?
  artist    String?
  duration  String?
  trackName String?
  title     String?
  license   String?
  userId    Int?
  teamId    Int

  isrcArtists IsrcArtists[]

  createdAt DateTime  @default(now())
  deletedAt DateTime?
  user      User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  team      Team      @relation(fields: [teamId], references: [id], onDelete: Cascade)
  artists   Artist[]
}

model tuStreamsArtists {
  id        Int         @id @default(autoincrement())
  artistId  Int
  tuStreams tuStreams[]
  createdAt DateTime    @default(now())
  userId    Int?
  teamId    Int

  user   User?  @relation(fields: [userId], references: [id], onDelete: SetNull)
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id])
}

enum TypeOfTuStreams {
  Sencillo
  Album
  Single
  EP
}

model tuStreams {
  id     Int              @id @default(autoincrement())
  title  String?
  UPC    String?
  artist String?
  type   TypeOfTuStreams?
  total  Float?
  date   DateTime?

  userId Int?
  teamId Int

  tuStreamsArtists tuStreamsArtists[]
  createdAt        DateTime           @default(now())
  deletedAt        DateTime?
  user             User?              @relation(fields: [userId], references: [id], onDelete: SetNull)
  team             Team               @relation(fields: [teamId], references: [id], onDelete: Cascade)
  artists          Artist[]
}

model FilesShareLink {
  id        Int      @id @default(autoincrement())
  email     String
  slug      String   @unique
  fileId    Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  document Files @relation(fields: [fileId], references: [id], onDelete: Cascade)

  @@unique([fileId, email])
}

model Files {
  id           Int                @id @default(autoincrement())
  qrToken      String? /// @zod.string.describe("The token for viewing the document using the QR code on the certificate.")
  userId       Int /// @zod.number.describe("The ID of the user that created this document.")
  user         User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  visibility   DocumentVisibility @default(EVERYONE)
  title        String
  status       DocumentStatus     @default(DRAFT)
  shareLinks   FilesShareLink[]
  fileDataId   String
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @default(now()) @updatedAt
  completedAt  DateTime?
  deletedAt    DateTime?
  teamId       Int
  useToChat    Boolean            @default(false)
  documentData DocumentData       @relation(fields: [fileDataId], references: [id], onDelete: Cascade)
  team         Team               @relation(fields: [teamId], references: [id], onDelete: Cascade)
  folder       Folder?            @relation(fields: [folderId], references: [id], onDelete: Cascade)
  folderId     String?

  @@unique([fileDataId])
  @@index([userId])
  @@index([status])
  @@index([folderId])
}
